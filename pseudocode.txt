/*

PARSING

input from readline is a string

-> count quotes 
	-> if enclosed
		-> error
loop until '\0'
{
	save number of processes in a struct needed for pipex
	(number of pipes + 1)
	
	iterate until '|' or '\0' 
		
		count redirections < & > (for malloc)
		save them in a 2d array, each string contains an operator with the filename "<filename" or ">filename"
		
		ft_substr to get what's in between the pipes
		remove all < > and their filenames from the string (change to spaces)
		ft_strtrim spaces from beginning and end of the string to get only the command and it's possible arguments
		
		fill a node for each process to create a list
		each node contains
			char	**redirs;	
			char	*cmd;		(cmd with it's args)
			int		fd_in;
			int		fd_out;
			char	*error_msg;
	
		if (files != NULL)
		check for file's permissions
		-> open every file wit < operator
		-> open and clear every file with > operator 
			-> if any of the files does not have rights
				-> error
					-> free node & move on to parsing next child's data
		save last < and last > fds in struct
		lst_add_back
}

at this point there should be a linked list with each node containing necessary information for one process
and number of processes saved in pipex's struct

PIPEX

in pipex get the correct fds
	-> if redirs != NULL 
		-> check rights to all of the files and clear the ones with >
			-> if we have no rights to one of the files save error status in the struct

before forking for the first time check if the command is a builtin or not
	-> some builtins need to be executed in the parent and some in the child

forking
	-> if error status indicates an error
		-> print out error message and end the child process
	else
	-> pipex will parse the command and it's arguments
	-> check if the cmd is a builtin to decide if the execve is needed
		-> if yes -> pipex will continue normally
		else pass the argument to the correct builtin function
		
s_pipex
	{
		int		processes;
		int		count;
		int		ends[2];
		int		read_end;
		char	**paths;
		char	*new_arg;
		char	**cmd;
		char	*path;
		int		*pids;
		bool	error;
		int		exitcode;
	}	t_pipex;
	
*/

export "what"="wer" what=wer
export what= qwer wer wer
export "what "= qwer wer wer 
export "1what"= qwer wer wer 
export "what"= "' wer'" wer wer 

Detailed Signal Descriptions
SIGINT: Typically sent when the user presses Ctrl+C in the terminal. It is often used to stop a running program.
SIGTERM: A polite way to ask a process to terminate. The process can catch and handle this signal, allowing it to perform cleanup operations before exiting.
SIGKILL: Forces the process to terminate immediately. It cannot be caught or ignored, ensuring the process stops immediately.
SIGSEGV: Indicates a segmentation fault, often due to invalid memory access (e.g., dereferencing a null pointer).
SIGUSR1 and SIGUSR2: User-defined signals for custom use in applications.
SIGALRM: Sent when a real-time timer set by alarm() expires.
SIGCHLD: Sent to a parent process when one of its child processes terminates or stops.
SIGHUP: Often used to reload configuration files without restarting the process, especially for daemon processes.
SIGPIPE: Sent when a process tries to write to a pipe with no readers, common in network and inter-process communication.
SIGSTOP: Pauses the process; cannot be caught or ignored, ensuring the process stops.
SIGCONT: Resumes a process that has been paused by SIGSTOP.
Practical Applications
Handling Interruptions: Use SIGINT to handle user interruptions gracefully.
Graceful Shutdowns: Use SIGTERM to allow processes to clean up before exiting.
Debugging: Use SIGSEGV to identify and handle segmentation faults in a program.
Custom Signals: Use SIGUSR1 and SIGUSR2 for application-specific signal handling.